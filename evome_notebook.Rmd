---
title: "EVome"
author: "Alex Cope"
date: "9/18/2020"
output:
  html_document:
    df_print: paged
---

```{r setup, include=FALSE,message=FALSE,warning=F,echo=F}
knitr::opts_chunk$set(echo = FALSE)

library(tidyverse)
require(reshape2)
library(preprocessCore)
library(DEP)
library(limma)
library(clusterProfiler)
library(cowplot)

nsaf <- function(spec.counts)
{
  nsaf.counts <- spec.counts[,which(colnames(spec.counts) != "Length")]
  prot.length <- spec.counts$Length
  nsaf.counts <- apply(nsaf.counts,2,function(x){x/prot.length})
  total.by.sample <- colSums(nsaf.counts,na.rm=T)
  nsaf.counts <- t(t(nsaf.counts)/total.by.sample)
  return(nsaf.counts)
}


filterByBioRep <- function(df)
{
  df$Treatment <- fct_collapse(df$Bio.Sample,Light=c("Light_1","Light_2","Light_3"),
                                  Heavy=c("Heavy_1","Heavy_2","Heavy_3"))
  
  treatment.count <- df %>% group_by(Treatment) %>% summarize(samples_present = sum(non_na_count!=0))
  if (treatment.count[1,2] < 2 && treatment.count[2,2] < 2)
  {
    return(NA)
  } else{
    return(df)
  }
}
```

I'm going to drop the Mixed sample for our data. Although Inna found that it was closer to Heavy EVs, it still could be considered its own group without any replicates. We have N=3 biological replicates for Heavy and Light EVs, which is the minimum we should have for differential expression analysis. 

Our data consists of multiple measurements taken on different instruments (Orbitrap, Eclipse) and on different days. This likely results in batch effects, which can reduce our signal of differential expression between the heavy and light fractions. Using the unique spectral counts values, let's cluster the different measurements to assess if we have a possible batch effect.

For differential expression analysis, we will use unique spectral counts for each protein. Also, we have the option to calculate NSAF values. We will use limma on log-transformed unique spectral counts following batch-correction, filtering, normalization, and imputation.


```{r data}
caeel.unique.sc <- read_tsv("Data/Abundance/CAEEL_unique_countsbysample.tsv",col_types = cols())
caeel.unique.sc <- caeel.unique.sc %>% column_to_rownames("Gene_name")
caeel.unique.sc <- caeel.unique.sc %>% dplyr::select(-Mixed)

colnames(caeel.unique.sc) <- paste(colnames(caeel.unique.sc),c("1","1","2","2","2","2","3","3","3","3","3","3","3"),sep=".")

batch.block <- fct_collapse(colnames(caeel.unique.sc),"1"=c("Light_01.1","Heavy_01.1"),
                              "2"=c("Light_02.2","Light_03.2","Heavy_02.2","Heavy_03.2"),
                              "3" = c("Light_04.3","Light_05.3","Light_06.3","Light_07.3","Heavy_04.3","Heavy_05.3","Heavy_06.3"))

```

```{r nsaf, warning=FALSE}
gene.length <- read_tsv("Data/gene_length.tsv",col_types = cols())
uniprot <- read_tsv("Data/Uniprot/uniprot-Caenorhabditis+elegans.tab",col_types = cols())
uniprot <- uniprot %>% mutate(Gene_names_ORF = trimws(Gene_names_ORF))
for (i in rownames(caeel.unique.sc))
{
  prot.size <- gene.length[which(gene.length$Gene_name == i),"Length"]
  min.size <- min(prot.size)
  if (is.infinite(min.size))
  {
    prot.size <- uniprot[which(uniprot$Gene_names_ORF == i | uniprot$Gene_names_primary == i | uniprot$Gene_names_synonym == i),"Length"]
    min.size <- min(prot.size)
  }
  caeel.unique.sc[i,"Length"] <- min.size
}

caeel.nsaf <- nsaf(caeel.unique.sc)
caeel.unique.sc <- caeel.unique.sc %>% dplyr::select(-Length)
```




```{r batch_check,echo = FALSE,warning=F,message=FALSE}
uncorrected.hclust <- hclust(dist(t(caeel.unique.sc)))

plot(uncorrected.hclust,xlab="Measurement",main="Before Batch Correction")
```


From the hierarchical clustering, it is Heavy_01 and Light_01 appear to be outliers, which is unsurprising given that they were measured on a different instrument. I'm going to apply the mean-centering correction method used in the Bioconductor package msmsEDA to reducte the batch effects. Note that the vignette for this tool states to treat missing values as 0. Question to investigate further: should we correct for batches before filtering (as done here) or after filtering of proteins with too many missing data points? 

```{r correct_batch,echo = FALSE,warning=F,message=FALSE}
caeel.sc.batch <- as.data.frame(msmsEDA::batch.neutralize(as.matrix(caeel.unique.sc),batch.block,half = T,sqrt.trans = T))

corrected.hclust <- hclust(dist(t(caeel.sc.batch)))
plot(corrected.hclust,xlab="Measurment",main="After Batch Correction")


write.table(caeel.sc.batch,"Data/Abundance/celegans_sc_unique_batch_correction.tsv",sep="\t",row.names=T,col.names=T,quote=F)
```


After applying the batch correction, Light_01 and Heavy_01 cluster with the other Light and Heavy EVomes, respectively. 

Now that we've applied our batch corrections, let's filter proteins. For our differential expression analysis, we ideally want proteins to be truly measured in 2 of the 3 biological replicates. We also don't want proteins with too many missing values, so we will also remove any proteins missing in more than half of the measurements. After removal of these proteins, we will impute the remaining missing values. 

```{r filter,fig.width=12,echo = FALSE,warning=F,message=FALSE}

## Using the original matrix, note which values were originally missing
caeel.sc.batch.na <- caeel.sc.batch
caeel.sc.batch.na[caeel.unique.sc == 0] <- NA
caeel.sc.batch <- caeel.sc.batch %>% rownames_to_column("Protein")
caeel.sc.batch.na <- caeel.sc.batch.na %>% rownames_to_column("Protein")

light.meas <- caeel.sc.batch.na %>% dplyr::select(Protein,contains("Light"))
heavy.meas <- caeel.sc.batch.na %>% dplyr::select(Protein,contains("Heavy"))

num.light <- ncol(light.meas) - 1
num.heavy <- ncol(heavy.meas) - 1

light.meas <- light.meas %>% rowwise() %>% mutate(numNA = sum(is.na(c_across(where(is.numeric)))))
heavy.meas <- heavy.meas %>% rowwise() %>% mutate(numNA = sum(is.na(c_across(where(is.numeric)))))



num.missing <- light.meas %>% 
               inner_join(heavy.meas,by="Protein",suffix=c("_Light","_Heavy")) %>% 
               dplyr::select(Protein,contains("numNA"))

only.heavy <- num.missing %>% 
              filter(numNA_Light == num.light & numNA_Heavy != num.heavy) %>% 
              dplyr::select(Protein) %>%
              deframe()
only.light <- num.missing %>% 
              filter(numNA_Light != num.light & numNA_Heavy == num.heavy) %>% 
              dplyr::select(Protein) %>%
              deframe()

light.or.heavy <- c(only.heavy,only.light)

caeel.sc.filter <- caeel.sc.batch.na %>% filter(!Protein %in% light.or.heavy)


caeel.sc.long <- caeel.sc.filter %>% pivot_longer(-Protein,names_to="Measurement",values_to="Abundance")

rep.by.sample <- fct_collapse(caeel.sc.long$Measurement,Light_1=c("Light_01.1"),
                                  Light_2=c("Light_02.2","Light_03.2"),
                                  Light_3=c("Light_04.3","Light_05.3","Light_06.3","Light_07.3"),
                                  Heavy_1=c("Heavy_01.1"),
                                  Heavy_2=c("Heavy_02.2","Heavy_03.2"),
                                  Heavy_3=c("Heavy_04.3","Heavy_05.3","Heavy_06.3"))


caeel.sc.long <- caeel.sc.long %>% mutate(Bio.Sample =rep.by.sample)


## Filter out proteins that are only observed in both the light and heavy samples 1 or fewer times
non.na.per.sample.by.gene <- caeel.sc.long  %>% dplyr::group_by(Protein,Bio.Sample) %>% 
    summarise(non_na_count = sum(!is.na(Abundance))) %>% 
    group_split()
enough.obs.list <- lapply(non.na.per.sample.by.gene ,filterByBioRep)
enough.obs.list <- enough.obs.list[which(!is.na(enough.obs.list))]
enough.obs.df <- enough.obs.list %>% bind_rows()
prot.to.keep <- unique(enough.obs.df$Protein)


caeel.sc.filter <- caeel.sc.filter %>% filter(Protein %in% prot.to.keep)
caeel.sc.filter <- caeel.sc.filter %>% rowwise() %>% mutate(numNA = sum(is.na(c_across(where(is.numeric))))) 

caeel.sc.filter <- caeel.sc.filter %>%
                     filter(numNA < 7) %>%
                     dplyr::select(-numNA)


```

After filtering, but before imputing, let's normalize our samples to make them more comparable. We will apply the quantile normalization.

```{r norm,,echo = FALSE,warning=F,message=FALSE}

caeel.sc.filter <- caeel.sc.filter %>% column_to_rownames("Protein") 
caeel.sc.filter.log2 <- log2(caeel.sc.filter)
caeel.sc.filter.log2.long <- caeel.sc.filter.log2 %>% pivot_longer(everything(),names_to="Measurement",values_to="Abundance") 

unnorm.boxplot <- ggplot(caeel.sc.filter.log2.long,aes(x=Measurement,y=Abundance)) + geom_boxplot() +
                  xlab("Measurement") + 
                  ylab("log2(Spectral Counts)") +
                  ggtitle("Log2(Spectral Counts) Distribution Per Sample:\nBefore Normalization") +
                  theme_cowplot() +
                  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
unnorm.boxplot


caeel.sc.norm <- normalize.quantiles(as.matrix(caeel.sc.filter))
caeel.sc.norm <- as.data.frame(caeel.sc.norm,row.names = rownames(caeel.sc.filter))
colnames(caeel.sc.norm) <- colnames(caeel.sc.filter)
caeel.sc.norm.log2 <- log2(caeel.sc.norm)
caeel.sc.norm.log2.long <- caeel.sc.norm.log2 %>% pivot_longer(everything(),names_to="Measurement",values_to="Abundance") 



norm.boxplot <- ggplot(caeel.sc.norm.log2.long,aes(x=Measurement,y=Abundance)) + geom_boxplot() +
                  xlab("Measurement") + 
                  ylab("log2(Spectral Counts)") +
                  ggtitle("Log2(Spectral Counts) Distribution Per Sample:\nAfter Normalization") +
                  theme_cowplot() +
                  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
norm.boxplot

```


Next, we will impute missing values. In proteomics, missing values are often described as either missing at random or missing not at random. The latter refers to situation in which low abundant proteins are missing across samples. We can check if this is the case.

```{r check,echo = FALSE,warning=F,message=FALSE}
treatment.by.sample <- fct_collapse(colnames(caeel.sc.norm),
                              Light=c("Light_01.1","Light_02.2","Light_03.2","Light_04.3","Light_05.3","Light_06.3","Light_07.3"),
                                  Heavy=c("Heavy_01.1","Heavy_02.2","Heavy_03.2","Heavy_04.3","Heavy_05.3","Heavy_06.3"))


colData <- data.frame(label=colnames(caeel.sc.norm),condition=treatment.by.sample,replicate=c(1,1,2,2,3,3,4,4,5,5,6,7,6),stringsAsFactors = F)
colData$condition <- as.character(colData$condition)

caeel.sc.norm.for.se <- caeel.sc.norm

caeel.sc.norm.for.se$name <- rownames(caeel.sc.norm)
caeel.sc.norm.for.se$ID <- rownames(caeel.sc.norm)
caeel.sc.norm.for.se[is.na(caeel.sc.norm.for.se)] <- 0
data_se <- DEP::make_se(as.data.frame(caeel.sc.norm.for.se),1:13,as.data.frame(colData))
plot_frequency(data_se)
plot_detect(data_se)

```



Based on the above plot, it appears that most of the missing values are from low abundant proteins. Here, we will use the QRILIC method of data imputation. We will set a random seed to increase reproducibility.

```{r check_missing,echo = FALSE,warning=F,message=FALSE}
set.seed(400)
data_imp <- DEP::impute(data_se,fun = "QRILC")
plot_imputation(data_imp)
```

DEP log2 transforms the values and then imputes. We will use this matrix as input into limma for comparing protein abundances between the Heavy and Light fractions of EVs.

```{r check_limma,echo = FALSE,warning=F,message=FALSE,fig.width=6,fig.height=7}

caeel.sc.log.imp <- get_df_wide(data_imp)
caeel.sc.log.imp.filt <- caeel.sc.log.imp[which(caeel.sc.log.imp$num_NAs < 14),]

rownames(caeel.sc.log.imp.filt) <- caeel.sc.log.imp.filt$name 

caeel.sc.log.imp.filt<-(caeel.sc.log.imp.filt 
                        %>% mutate(Mean.abundance=rowMeans(dplyr::select(.,starts_with(c("Heavy","Light")))))
                        #%>% filter(Mean.abundance > -13.6)
                        %>% filter(Mean.abundance > 0.25)
                        %>% dplyr::select(-Mean.abundance)
)

rownames(caeel.sc.log.imp.filt) <- caeel.sc.log.imp.filt$name 
caeel.sc.log.imp.filt <- caeel.sc.log.imp.filt[,2:14]


tech.rep.by.sample <- fct_collapse(colnames(caeel.sc.log.imp.filt),Light_1=c("Light_1"),
                                  Light_2=c("Light_2","Light_3"),
                                  Light_3=c("Light_4","Light_5","Light_6","Light_7"),
                                  Heavy_1=c("Heavy_1"),
                                  Heavy_2=c("Heavy_2","Heavy_3"),
                                  Heavy_3=c("Heavy_4","Heavy_5","Heavy_6"))




cols <- colnames(caeel.sc.log.imp.filt)
sample.names <- unlist(strsplit(cols,split="_[0-9]"))
f <- factor(cols,levels=cols,labels=sample.names)
design <- model.matrix(~0+f)
colnames(design) <- unique(sample.names)

fit <- lmFit(caeel.sc.log.imp.filt,design)
AW <- arrayWeights(caeel.sc.log.imp.filt, design)
dupcor <- duplicateCorrelation(caeel.sc.log.imp.filt, design, block=tech.rep.by.sample) #correlation between technical replicates

fit.w.weights <- lmFit(caeel.sc.log.imp.filt,design,block=tech.rep.by.sample,correlation = dupcor$consensus.correlation,weights = AW)
plotSA(fit.w.weights)

resid <- residuals(fit,caeel.sc.log.imp.filt)
```

Based on this plot, seems like our data matches the assumptions of limma. Now let's perform our differential expression analysis.

```{r limma,echo = FALSE,warning=F,message=FALSE,fig.width=6,fig.height=7}
## Differential expression analysis following recommendation here: https://support.bioconductor.org/p/64484/
cont.ev <- makeContrasts("Heavy-Light",levels=design)
fit.ev.w.weights <- contrasts.fit(fit.w.weights,cont.ev)
fit.ev.w.weights <- eBayes(fit.ev.w.weights,robust = T,trend=T)

plotSA(fit.ev.w.weights)
diff.exp.w.weights<- topTable(fit.ev.w.weights,number = nrow(caeel.sc.log.imp.filt))

diff.exp.top.w.weights<- diff.exp.w.weights %>% filter(abs(logFC) >= 1.5 & adj.P.Val < 0.05) %>% rownames_to_column("Protein")

diff.exp.top.w.weights <- diff.exp.top.w.weights %>% left_join(caeel.sc.batch,by="Protein")

```

Based on the limma analysis, we detect 234 genes with an absolute log2 fold change of at least 1.5 and adjusted p-value < 0.05 out of the 836 proteins, following filtering. Now let's perform a KEGG enrichment of the genes which appear differentially between the heavy and light strains. 

```{r echo=F}

gene.to.kegg <- read_tsv("Data/ID_map/bioDBnet_db2db_2021_09_01.txt",col_types = cols())
kegg.to.gene <- read_tsv("Data/ID_map/bioDBnet_db2db_2021_09_01.txt",col_types = cols())

kegg.to.gene <- kegg.to.gene %>% filter(KEGG_Gene_ID != "-") %>% 
                mutate(KEGG_Gene_ID=str_remove(KEGG_Gene_ID,"cel:")) %>%
                column_to_rownames("KEGG_Gene_ID")

gene.to.kegg <- gene.to.kegg %>% column_to_rownames("Gene_Symbol")

gene.to.kegg[which(gene.to.kegg$KEGG_Gene_ID== "-"),"KEGG_Gene_ID"] <- paste0("CELE_",rownames(gene.to.kegg)[which(gene.to.kegg$KEGG_Gene_ID == "-")])

gene.to.kegg <- gene.to.kegg %>% mutate(KEGG_Gene_ID=str_remove(KEGG_Gene_ID,"cel:"))

gene.universe <- gene.to.kegg[rownames(caeel.unique.sc),"KEGG_Gene_ID"]


## Enrichment of differentially expressed proteins regardless if it is up-regulated in Heavy or Light EVs. Also include proteins unique to one of the EVs

diff.exp.kegg.ids <- gene.to.kegg[diff.exp.top.w.weights$Protein,"KEGG_Gene_ID"]
diff.exp.kegg.ids <- c(diff.exp.kegg.ids,only.heavy,only.light)

enrichment <- enrichKEGG(diff.exp.kegg.ids,organism = "cel",pvalueCutoff = 0.05,pAdjustMethod = "BH",qvalueCutoff = 0.1,universe = gene.universe)

enrichment@result$Gene_name <- unlist(lapply(str_split(enrichment@result$geneID,"/"),function(x){
         tmp <- kegg.to.gene[x,"Gene_Symbol"]
         tmp[which(is.na(tmp))] <- str_remove(x[which(is.na(tmp))],"CELE_")
         paste(tmp,collapse=",")
        }
  ))

write_tsv(enrichment@result,"Results/differentially_expressed_kegg_enrichment_sc_20211102.tsv")

## Enrichment of differentially expressed proteins up-regulated in Heavy EVs. Also include proteins unique to Heavy EVs.

diff.exp.kegg.ids <- gene.to.kegg[diff.exp.top.w.weights[which(diff.exp.top.w.weights$logFC > 0),"Protein"],"KEGG_Gene_ID"]
only.heavy.kegg <- gene.to.kegg[only.heavy,"KEGG_Gene_ID"]
heavy.kegg <- c(only.heavy.kegg,diff.exp.kegg.ids)
heavy.enrichment <- enrichKEGG(heavy.kegg,organism = "cel",pvalueCutoff = 0.05,pAdjustMethod = "BH",qvalueCutoff = 0.1,universe = gene.universe)

heavy.enrichment@result$Gene_name <- unlist(lapply(str_split(heavy.enrichment@result$geneID,"/"),function(x){
         tmp <- kegg.to.gene[x,"Gene_Symbol"]
         tmp[which(is.na(tmp))] <- str_remove(x[which(is.na(tmp))],"CELE_")
         paste(tmp,collapse=",")
        }
  ))

write_tsv(heavy.enrichment@result,"Results/heavy_fraction_upregulated_kegg_enrichment_sc_20211102.tsv")

## Enrichment of differentially expressed proteins up-regulated in Light EVs. Also include proteins unique to Light EVs.

diff.exp.kegg.ids <- gene.to.kegg[diff.exp.top.w.weights[which(diff.exp.top.w.weights$logFC < 0),"Protein"],"KEGG_Gene_ID"]
only.light.kegg <- gene.to.kegg[only.light,"KEGG_Gene_ID"]
light.kegg <- c(only.light.kegg,diff.exp.kegg.ids)
light.enrichment <- enrichKEGG(light.kegg,organism = "cel",pvalueCutoff = 0.05,pAdjustMethod = "BH",qvalueCutoff = 0.1,universe = gene.universe)

light.enrichment@result$Gene_name <- unlist(lapply(str_split(light.enrichment@result$geneID,"/"),function(x){
         tmp <- kegg.to.gene[x,"Gene_Symbol"]
         tmp[which(is.na(tmp))] <- str_remove(x[which(is.na(tmp))],"CELE_")
         paste(tmp,collapse=",")
        }
  ))

write_tsv(light.enrichment@result,"Results/light_fraction_upregulated_kegg_enrichment_sc_20211102.tsv")


## Enrichment of EV proteins relative to genomic background.

all <- gene.to.kegg[rownames(caeel.unique.sc),"KEGG_Gene_ID"]
all.enrichment <- enrichKEGG(all,organism = "cel",pvalueCutoff = 0.05,pAdjustMethod = "BH",qvalueCutoff = 0.1)
all.enrichment@result$Gene_name <- unlist(lapply(str_split(all.enrichment@result$geneID,"/"),function(x){
         tmp <- kegg.to.gene[x,"Gene_Symbol"]
         tmp[which(is.na(tmp))] <- str_remove(x[which(is.na(tmp))],"CELE_")
         paste(tmp,collapse=",")
        }
  ))

write_tsv(all.enrichment@result,"Results/evome_vs_background_kegg_enrichment_sc_20211102.tsv")


```

Reviewer requested that we perform the EVome enrichment against the background set that includes protein identified ambiguously, as well. Inna provided a list of proteins identified via ambiguous peptides. Results largely remain unchanged.

```{r}
ambiguous <- read_tsv("Data/ID_map/bioDBnet_db2db_2021_11_02.txt")
ambiguous <- ambiguous %>% filter(`KEGG Gene ID` != "-") %>% mutate(`KEGG Gene ID` = str_remove(`KEGG Gene ID`,"cel:"))
gene.universe.ambig <- unique(c(gene.universe,ambiguous$`KEGG Gene ID`))

diff.exp.kegg.ids <- gene.to.kegg[diff.exp.top.w.weights$Protein,"KEGG_Gene_ID"]
diff.exp.kegg.ids <- c(diff.exp.kegg.ids,only.heavy,only.light)

enrichment.ambig <- enrichKEGG(diff.exp.kegg.ids,organism = "cel",pvalueCutoff = 0.05,pAdjustMethod = "BH",qvalueCutoff = 0.1,universe = gene.universe.ambig)

enrichment.ambig@result$Gene_name <- unlist(lapply(str_split(enrichment.ambig@result$geneID,"/"),function(x){
         tmp <- kegg.to.gene[x,"Gene_Symbol"]
         tmp[which(is.na(tmp))] <- str_remove(x[which(is.na(tmp))],"CELE_")
         paste(tmp,collapse=",")
        }
  ))

write_tsv(enrichment.ambig@result,"Results/differentially_expressed_kegg_enrichment_sc_20211102_ambig_protein_background.tsv")

## Enrichment of differentially expressed proteins up-regulated in Heavy EVs. Also include proteins unique to Heavy EVs.

diff.exp.kegg.ids <- gene.to.kegg[diff.exp.top.w.weights[which(diff.exp.top.w.weights$logFC > 0),"Protein"],"KEGG_Gene_ID"]
only.heavy.kegg <- gene.to.kegg[only.heavy,"KEGG_Gene_ID"]
heavy.kegg <- c(only.heavy.kegg,diff.exp.kegg.ids)
heavy.enrichment.ambig <- enrichKEGG(heavy.kegg,organism = "cel",pvalueCutoff = 0.05,pAdjustMethod = "BH",qvalueCutoff = 0.1,universe = gene.universe.ambig)

heavy.enrichment.ambig@result$Gene_name <- unlist(lapply(str_split(heavy.enrichment.ambig@result$geneID,"/"),function(x){
         tmp <- kegg.to.gene[x,"Gene_Symbol"]
         tmp[which(is.na(tmp))] <- str_remove(x[which(is.na(tmp))],"CELE_")
         paste(tmp,collapse=",")
        }
  ))

write_tsv(heavy.enrichment.ambig@result,"Results/heavy_fraction_upregulated_kegg_enrichment_sc_20211102_ambig_protein_background.tsv")

## Enrichment of differentially expressed proteins up-regulated in Light EVs. Also include proteins unique to Light EVs.

diff.exp.kegg.ids <- gene.to.kegg[diff.exp.top.w.weights[which(diff.exp.top.w.weights$logFC < 0),"Protein"],"KEGG_Gene_ID"]
only.light.kegg <- gene.to.kegg[only.light,"KEGG_Gene_ID"]
light.kegg <- c(only.light.kegg,diff.exp.kegg.ids)
light.enrichment.ambig <- enrichKEGG(light.kegg,organism = "cel",pvalueCutoff = 0.05,pAdjustMethod = "BH",qvalueCutoff = 0.1,universe = gene.universe.ambig)

light.enrichment.ambig@result$Gene_name <- unlist(lapply(str_split(light.enrichment.ambig@result$geneID,"/"),function(x){
         tmp <- kegg.to.gene[x,"Gene_Symbol"]
         tmp[which(is.na(tmp))] <- str_remove(x[which(is.na(tmp))],"CELE_")
         paste(tmp,collapse=",")
        }
  ))

write_tsv(light.enrichment.ambig@result,"Results/light_fraction_upregulated_kegg_enrichment_sc_20211102_ambig_protein_background.tsv")


all.enrichment.ambig <- enrichKEGG(gene.universe.ambig,organism = "cel",pvalueCutoff = 0.05,pAdjustMethod = "BH",qvalueCutoff = 0.1)
all.enrichment.ambig@result$Gene_name <- unlist(lapply(str_split(all.enrichment.ambig@result$geneID,"/"),function(x){
         tmp <- kegg.to.gene[x,"Gene_Symbol"]
         tmp[which(is.na(tmp))] <- str_remove(x[which(is.na(tmp))],"CELE_")
         paste(tmp,collapse=",")
        }
  ))

write_tsv(all.enrichment.ambig@result,"Results/evome_vs_background_kegg_enrichment_sc_20211102_ambig_protein_background.tsv")


```

The following code was developed by Inna for performing enrichment tests of InterPro domains in the EVome dataset relative to the background.

```{r echo = F}
#Import domain info for the whole proteome (sourced from Ensembl Biomart)
ElegansGenomeDomainInfo <- read.csv("Data/Domain/ElegansGenomeInterProInfo.csv")

#Remove empty InterProID entries
ElegansGenomeDomainInfo <- ElegansGenomeDomainInfo[-which(ElegansGenomeDomainInfo$Interpro.ID == ""), ]

#Extarct domain IDs
GlobalDomainList <- unique(ElegansGenomeDomainInfo$Interpro.ID)

#Extract unique genes to calculate the size of the proteome
GlobalGeneList <- unique(ElegansGenomeDomainInfo$Gene.stable.ID)
length(GlobalGeneList)

#Calculate frequency of occurence for each domain
a <- rle(sort(ElegansGenomeDomainInfo$Interpro.ID))
BackgroundFrequencies <- data.frame(InterProDomain=a$values, BackgroundOccurence=a$lengths)

#Import doamin info for the EVome (sourced from Ensembl Biomart)
EVomeDomainInfo <- read.csv("Data/Domain/EVomeDomainInfo.csv")
#Kill empty InterProID entries
EVomeDomainInfo <- EVomeDomainInfo[-which(EVomeDomainInfo$Interpro.ID == ""), ]

#Extract unique EV proteins to calculate the size of the EVome with assigned domains
EVomeDomainProteinList <- unique(EVomeDomainInfo$Gene.stable.ID)
length(EVomeDomainProteinList)


#Calculate frequency of occurence for each domain
b <- rle(sort(EVomeDomainInfo$Interpro.ID))
EVomeFrequencies <- data.frame(InterProDomain=b$values, EVomeOccurence=b$lengths)

#Generate data frame of EVome domain IDs with EVome and Background frequencies
Summary <- merge(EVomeFrequencies, BackgroundFrequencies, 
                                        by = "InterProDomain", 
                                        all.x=TRUE, all.y=FALSE)
Summary$EVomeFrequency <- Summary$EVomeOccurence/length(EVomeDomainProteinList)
Summary$ProteomeFrequency <- Summary$BackgroundOccurence/length(GlobalGeneList)
Summary$Enrichment <- Summary$EVomeFrequency/Summary$ProteomeFrequency

#Calculate p-value using hypergeometric distribution model
#EVome size = 2,888 proteins
#Proteome size = 14,904 proteins
#http://mengnote.blogspot.com/2012/12/calculate-correct-hypergeometric-p.html
#phyper(success-in-sample, success-in-bkgd, failure-in-bkgd, sample-size)
# 
# Summary$p_value <- 1-phyper(Summary$EVomeOccurence-1, 
#                                      Summary$BackgroundOccurence,
#                             20191-Summary$BackgroundOccurence,
#                             2888)


## For the enrichment test, we probably only want to include proteins with some form of annotation. Proteins with missing information are not particularly informative. You can also simplify your code slightly by setting lower.tail = F instead of subtracting from 1. 
Summary$p_value <- phyper(Summary$EVomeOccurence - 1,
                                     Summary$BackgroundOccurence,
                            length(GlobalGeneList)-Summary$BackgroundOccurence,
                            length(EVomeDomainProteinList), lower.tail = F)



#Benjamini-Hochberg method to calculate p-adjusted
Summary$padj <- p.adjust(Summary$p_value, method="BH")

Summary$neglog10_padj <- -log10(Summary$padj) 

Summary <- Summary %>% rename(adjusted_pval=padj,negative_log10_adjusted_pval = neglog10_padj )

SpC_byDomain <- EVomeDomainInfo %>%
  group_by(Interpro.ID) %>%
  summarise(SumCounts = sum(SpectralCounts))

Summary <- merge(Summary, SpC_byDomain, 
                 by.x="InterProDomain", by.y="Interpro.ID",
                 all.x=TRUE, all.y=FALSE)

Summary <- merge(Summary, EVomeDomainInfo[,c("Interpro.ID","Interpro.Description")], 
                 by.x="InterProDomain", by.y="Interpro.ID",
                 all.x=TRUE, all.y=FALSE)

Summary <- unique(Summary)
Summary <- Summary %>% arrange(adjusted_pval)
write_csv(Summary, "Results/SummaryDomainEnrichment_20211108.csv")


```

As with the KEGG enrichments, we now want to include proteins that were ambiguous in our enrichments. 
```{r echo = F}


ambiguous <- read_tsv("Data/ProteinsIdentifiedUnambiguouslyOnly.tsv") %>% dplyr::select(Gene_name,`Wormbase IDs`)

#Import domain info for the whole proteome (sourced from Ensembl Biomart)
ElegansGenomeDomainInfo <- read.csv("Data/Domain/ElegansGenomeInterProInfo.csv")

#Remove empty InterProID entries
ElegansGenomeDomainInfo <- ElegansGenomeDomainInfo[-which(ElegansGenomeDomainInfo$Interpro.ID == ""), ]

#Extarct domain IDs
GlobalDomainList <- unique(ElegansGenomeDomainInfo$Interpro.ID)

#Extract unique genes to calculate the size of the proteome
GlobalGeneList <- unique(ElegansGenomeDomainInfo$Gene.stable.ID)
length(GlobalGeneList)

#Calculate frequency of occurence for each domain
a <- rle(sort(ElegansGenomeDomainInfo$Interpro.ID))
BackgroundFrequencies <- data.frame(InterProDomain=a$values, BackgroundOccurence=a$lengths)

#Import doamin info for the EVome (sourced from Ensembl Biomart)
EVomeDomainInfo <- read.csv("Data/Domain/EVomeDomainInfo.csv")
#Kill empty InterProID entries
EVomeDomainInfo <- EVomeDomainInfo[-which(EVomeDomainInfo$Interpro.ID == ""), ]
ambiguousDomainInfo <- ElegansGenomeDomainInfo %>% filter(Gene.stable.ID %in% ambiguous$`Wormbase IDs`)



EVomeDomainInfo <- list(EVomeDomainInfo,ambiguousDomainInfo) %>% bind_rows() %>% distinct(Gene.stable.ID,Interpro.ID,.keep_all = T)


#Extract unique EV proteins to calculate the size of the EVome with assigned domains
EVomeDomainProteinList <- unique(EVomeDomainInfo$Gene.stable.ID)
length(EVomeDomainProteinList)

#Calculate frequency of occurence for each domain
b <- rle(sort(EVomeDomainInfo$Interpro.ID))
EVomeFrequencies <- data.frame(InterProDomain=b$values, EVomeOccurence=b$lengths)

#Generate data frame of EVome domain IDs with EVome and Background frequencies
Summary <- merge(EVomeFrequencies, BackgroundFrequencies, 
                                        by = "InterProDomain", 
                                        all.x=TRUE, all.y=FALSE)
Summary$EVomeFrequency <- Summary$EVomeOccurence/length(EVomeDomainProteinList)
Summary$ProteomeFrequency <- Summary$BackgroundOccurence/length(GlobalGeneList)
Summary$Enrichment <- Summary$EVomeFrequency/Summary$ProteomeFrequency

#Calculate p-value using hypergeometric distribution model
#EVome size = 2,888 proteins
#Proteome size = 14,904 proteins
#http://mengnote.blogspot.com/2012/12/calculate-correct-hypergeometric-p.html
#phyper(success-in-sample, success-in-bkgd, failure-in-bkgd, sample-size)
# 
# Summary$p_value <- 1-phyper(Summary$EVomeOccurence-1, 
#                                      Summary$BackgroundOccurence,
#                             20191-Summary$BackgroundOccurence,
#                             2888)


## For the enrichment test, we probably only want to include proteins with some form of annotation. Proteins with missing information are not particularly informative. You can also simplify your code slightly by setting lower.tail = F instead of subtracting from 1. 
Summary$p_value <- phyper(Summary$EVomeOccurence - 1,
                                     Summary$BackgroundOccurence,
                            length(GlobalGeneList)-Summary$BackgroundOccurence,
                            length(EVomeDomainProteinList), lower.tail = F)



#Benjamini-Hochberg method to calculate p-adjusted
Summary$padj <- p.adjust(Summary$p_value, method="BH")

Summary$neglog10_padj <- -log10(Summary$padj) 

Summary <- Summary %>% rename(adjusted_pval=padj,negative_log10_adjusted_pval = neglog10_padj)

SpC_byDomain <- EVomeDomainInfo %>%
  group_by(Interpro.ID) %>%
  summarise(SumCounts = sum(SpectralCounts,na.rm=T))

Summary <- merge(Summary, SpC_byDomain, 
                 by.x="InterProDomain", by.y="Interpro.ID",
                 all.x=TRUE, all.y=FALSE)

Summary <- merge(Summary, EVomeDomainInfo[,c("Interpro.ID","Interpro.Description")], 
                 by.x="InterProDomain", by.y="Interpro.ID",
                 all.x=TRUE, all.y=FALSE)

Summary <- unique(Summary)
Summary <- Summary %>% arrange(adjusted_pval)
write_csv(Summary, "Results/SummaryDomainEnrichment_20211108_w_ambiguous.csv")


```

